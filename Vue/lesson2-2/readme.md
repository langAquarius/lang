# 解构赋值

1、数组
let []=[]
2、对象
let {a,b}={a:"hei",b:"nan"}

解构成功
let [a, b, c] = [1, 2, 3];
---------------------------------------------
不完全解构？
---------------------------------------------
//3没有变量名接收，所以 这个解构赋值没有完全解构
let [a,b]=[1,2,3]
解构不成功
---------------------------------------------
let [foo] = [];
let [bar, foo] = [1];
两边比配的模式不正确
let []={}
let {}=[]
默认值
---------------------------------------------
let [a=1]=[]
console.log(a)
函数参数的解构赋值


...reset 参数来代替arguments

尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。


函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。



# 数组

深拷贝
	从内存当中复制一份儿，arr1和arr2没有关系
浅拷贝
	内存当中的指针指向，arr1修改会影响arr2

扩展运算符还可以将字符串转为真正的数组。


将两类对象转为真正的数组：
类似数组的对象（array-like object）
和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）
Array.from()


Array.of方法用于将一组值，转换为数组。

数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。